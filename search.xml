<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[numpy]]></title>
    <url>%2F2018%2F02%2F01%2Fnumpy%2F</url>
    <content type="text"><![CDATA[1.numpy中的基本数据类型 名称 描述 bool 用一个字节存储的布尔类型（True或False） inti 由所在平台决定其大小的整数（一般为int32或int64） int8 一个字节大小，-128 至 127 int16 整数，-32768 至 32767 int32 整数，-231 至 232-1 int64 整数，-263 至 263 - 1 uint8 无符号整数，0 至 255 uint16 无符号整数，0 至 65535 uint32 无符号整数，0 至 232 - 1 uint64 无符号整数，0 至 264 - 1 float16 半精度浮点数：16位，正负号1位，指数5位，精度10位 float32 单精度浮点数：32位，正负号1位，指数8位，精度23位 float64或float 双精度浮点数：64位，正负号1位，指数11位，精度52位 complex64 复数，分别用两个32位浮点数表示实部和虚部 complex128或complex 复数，分别用两个64位浮点数表示实部和虚部 2.用于操作单个数组的常用函数 函数 说明 sort(x) 对x进行从小到大排序 unique(x) 计算x中的唯一元素，并返回有序结果 abs、fabs 计算整数、浮点数或复数的绝对值。对于复数数值，可以使用更快的fabs square 计算各元素的平方 sqrt 计算各元素的平方根 cos、sin、tan 三角函数 arccos、arcsin、arctan 反三角函数 3.用于操作两个或多个数组的方法 函数 说明 add 将数组中对应的元素相加 subtract 从第一个数组中减去第二个数组中的元素 multiply 数组元素相乘 power 两个数组A,B，计算A的B次方 mod 元素级的求模运算 4.数学统计方法 方法 说明 sum 求和 mean 算术平均数。零长度的数组为NaN std、var 分别为标准差和方差 min，max 最小值和最大值 cumsum 所有元素的累积和 cumprod 所有元素的累积积 argmin、argmax 分别计算最小值和最大值的索引 5.线性函数的常用方法 函数 描述 dot 矩阵乘法 trace 计算对角线元素的和 det 计算矩阵行列式 inv 计算方阵的逆 pinv 计算矩阵的逆 6.实例 >&gt;&gt; import numpy as np 调用numpy库>&gt;&gt; a = np.array([1,2,3]) 创建数组，且大小固定，不可变>&gt;&gt; aarray([1, 2, 3])>&gt;&gt; a.dtype 查看新建的ndarray属于哪种数据类型dtype(‘int32’)>&gt;&gt; a.ndim 数组的维统称为轴，得出轴数量（秩）1>&gt;&gt; a.size 数组的长度3>&gt;&gt; a.shape 数组的型(3,)>&gt;&gt; b = np.array([[1,2,3],[2,3,4]]) 创建二维数组>&gt;&gt; barray([[1, 2, 3], [2, 3, 4]])>&gt;&gt; c = np.array(((1,2,4),(4,5,6)))>&gt;&gt; carray([[1, 2, 4], [4, 5, 6]])>&gt;&gt; d = np.array([(1,2,3),[4,5,6],(7,8,9)])>&gt;&gt; darray([[1, 2, 3], [4, 5, 6], [7, 8, 9]])>&gt;&gt; f = np.array([(1,2,3),[4,5,6],(7,8,9)],dtype = complex) complex为复数类型>&gt;&gt; farray([[ 1.+0.j, 2.+0.j, 3.+0.j], [ 4.+0.j, 5.+0.j, 6.+0.j], [ 7.+0.j, 8.+0.j, 9.+0.j]])>&gt;&gt; np.zeros((3,3)) 生成全0的数组array([[ 0., 0., 0.], [ 0., 0., 0.], [ 0., 0., 0.]])>&gt;&gt; np.ones((3,3)) 生成全1的数组array([[ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.]]) empty()函数，随机生成数组，相当于未进行初始化的数组。不同平台调用会生成不同的结果。(2,3,2)：2个3行2列的数组。>&gt;&gt;np.empty((2,3,2))>&gt;&gt; np.arange(0,10) 遍历输出array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])>&gt;&gt; np.arange(0,10,3) 类似于列表，不同的是列表的大小可以改变array([0, 3, 6, 9])>&gt;&gt; np.arange(0,12).reshape(3,4) 生成3行4列的数组array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])>&gt;&gt; np.random.random((3,3)) 产生随机数array([[ 0.24683936, 0.49185243, 0.30907375], [ 0.73396599, 0.56047708, 0.07133656], [ 0.46251468, 0.00697587, 0.9234071 ]])>&gt;&gt; A = np.ones((3,3))>&gt;&gt; Aarray([[ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.]])>&gt;&gt; B = np.arange(0,9).reshape(3,3)>&gt;&gt; Barray([[0, 1, 2], [3, 4, 5], [6, 7, 8]])>&gt;&gt; np.dot(A,B) dot表示两个数组的矩阵积array([[ 9., 12., 15.], [ 9., 12., 15.], [ 9., 12., 15.]])>&gt;&gt; A.dot(B) 矩阵积的第二种表示形式array([[ 9., 12., 15.], [ 9., 12., 15.], [ 9., 12., 15.]]) 数学运算>&gt;&gt; g = np.arange(4)>&gt;&gt; garray([0, 1, 2, 3])>&gt;&gt; g += 1>&gt;&gt; garray([1, 2, 3, 4])>&gt;&gt; g -= 2>&gt;&gt; garray([-1, 0, 1, 2])>&gt;&gt; h = np.arange(1,5)>&gt;&gt; harray([1, 2, 3, 4])>&gt;&gt; np.sqrt(h) 开平方array([ 1. , 1.41421356, 1.73205081, 2. ])>&gt;&gt; np.sin(h)array([ 0.84147098, 0.90929743, 0.14112001, -0.7568025 ])>&gt;&gt; np.log(h)array([ 0. , 0.69314718, 1.09861229, 1.38629436])>&gt;&gt; k = np.array([3,4,5,6,7])>&gt;&gt; k.sum() 求和25>&gt;&gt; k.min() 最小值3>&gt;&gt; k.max() 最大值7>&gt;&gt; k.mean() 平均值5.0>&gt;&gt; k.std() 标准差1.4142135623730951>&gt;&gt; l = np.arange(10,19).reshape((3,3))>&gt;&gt; larray([[10, 11, 12], [13, 14, 15], [16, 17, 18]])>&gt;&gt; np.apply_along_axis(np.mean,axis = 0,arr = l) 遍历每个元素，求每一列的平均值array([ 13., 14., 15.])>&gt;&gt; np.apply_along_axis(np.mean,axis = 1,arr = l) 求每一行的平均值array([ 11., 14., 17.])>&gt;&gt; m = np.random.random((4,4))>&gt;&gt; marray([[ 0.08614139, 0.7518394 , 0.45196265, 0.68611206], [ 0.62034675, 0.52529466, 0.72000524, 0.90689477], [ 0.19201244, 0.4555663 , 0.16900424, 0.76753676], [ 0.17563723, 0.6348416 , 0.38004357, 0.92354182]])>&gt;&gt; b = np.random.random(12)>&gt;&gt; barray([ 0.56181788, 0.16499619, 0.6756252 , …, 0.33440496, 0.75068239, 0.08420334])>&gt;&gt; b.shape = (3,4) 把元组赋给数组shape的属性>&gt;&gt; barray([[ 0.56181788, 0.16499619, 0.6756252 , 0.37539411], [ 0.53771165, 0.96114175, 0.58014551, 0.05676748], [ 0.31388188, 0.33440496, 0.75068239, 0.08420334]])>&gt;&gt; b.ravel() 把二维数组变为一维数组array([ 0.56181788, 0.16499619, 0.6756252 , …, 0.33440496, 0.75068239, 0.08420334])>&gt;&gt; b.transpose() 行列转换array([[ 0.56181788, 0.53771165, 0.31388188], [ 0.16499619, 0.96114175, 0.33440496], [ 0.6756252 , 0.58014551, 0.75068239], [ 0.37539411, 0.05676748, 0.08420334]])>&gt;&gt; A = np.zeros((3,3))>&gt;&gt; B = np.ones((3,3))>&gt;&gt; np.vstack((A,B)) 执行垂直入栈操作array([[ 0., 0., 0.], [ 0., 0., 0.], [ 0., 0., 0.], [ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.]])>&gt;&gt; np.hstack((A,B)) 执行水平入栈操作array([[ 0., 0., 0., 1., 1., 1.], [ 0., 0., 0., 1., 1., 1.], [ 0., 0., 0., 1., 1., 1.]]) 用于多个数组之间的栈操作>&gt;&gt; d = np.array([1,2,3])>&gt;&gt; e = np.array([4,5,6])>&gt;&gt; f = np.array([7,8,9])>&gt;&gt; np.column_stack((d,e,f)) 把一维数组作为列压入栈array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])>&gt;&gt; np.row_stack((d,e,f)) 把一维数组作为行压入栈array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])>&gt;&gt; C = np.arange(16).reshape((4,4))>&gt;&gt; Carray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])>&gt;&gt; [D,E] = np.hsplit (C,2) 将数组水平切分>&gt;&gt; Darray([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]])>&gt;&gt; Earray([[ 2, 3], [ 6, 7], [10, 11], [14, 15]])>&gt;&gt; [D,E] = np.vsplit (C,2) 将数组垂直切分>&gt;&gt; Darray([[0, 1, 2, 3], [4, 5, 6, 7]])>&gt;&gt; Earray([[ 8, 9, 10, 11], [12, 13, 14, 15]]) Numpy中，所有赋值运算不会为数组和数组中的任何元素创建副本。把数组a赋给数组b，b只是a的另外一种调用方式。>&gt;&gt; import numpy as np>&gt;&gt; a = np.array([1,2,3,4])>&gt;&gt; b = a>&gt;&gt; barray([1, 2, 3, 4])>&gt;&gt; a[2] = 5>&gt;&gt; barray([1, 2, 5, 4])>&gt;&gt; aarray([1, 2, 5, 4]) 利用copy()函数可以生成一份完整的副本，得到一个不同的数组。>&gt;&gt; d = a.copy()>&gt;&gt; darray([0, 2, 5, 4])>&gt;&gt; a[2] = 3>&gt;&gt; aarray([0, 2, 3, 4])>&gt;&gt; darray([0, 2, 5, 4]) 数组切片操作返回的对象只是原数组的视图。>&gt;&gt; l = np.arange(10,19).reshape((3,3))>&gt;&gt; larray([[10, 11, 12], [13, 14, 15], [16, 17, 18]])>&gt;&gt; l[2,2] 表示第3行3列的元素，从0开始18>&gt;&gt; l[1,2]15>&gt;&gt; l[0,:] 第0行的元素array([10, 11, 12])>&gt;&gt; l[:,0] 第0列的元素array([10, 13, 16])>&gt;&gt; l[0:2,0:2] 截取前两行前两列的元素array([[10, 11], [13, 14]])>&gt;&gt; l[[0,2],0:2] 截取前两列中第0行、第2行的元素array([[10, 11], [16, 17]])>&gt;&gt; c = a[0:2]>&gt;&gt; carray([1, 2])>&gt;&gt; a[0] = 0>&gt;&gt; carray([0, 2])>&gt;&gt; d = np.array([[1,2,3],[4,5,6],[7,8,9]])>&gt;&gt; darray([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 切片：一个逗号表示一个维度。:2表示数组的前两行(0,1行)，1：数组的1列到最后一列。>&gt;&gt; d[:2,1:]array([[2, 3], [5, 6]])>&gt;&gt; d[:2]array([[1, 2, 3], [4, 5, 6]]) 可以利用切片为数组赋值。>&gt;&gt; d[1:,2:] = 0>&gt;&gt; darray([[1, 2, 3], [4, 5, 0], [7, 8, 0]])]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2018%2F01%2F26%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo搭建博客基本命令添加相关页面打开终端，进入博客根站点目录下，例：添加标签页，输入以下内容： hexo new page tags 生成静态文件 hexo g 本地预览 hexo s 部署到GitHub打开终端，进入public hexo d 但往往hexo d不起作用，我的是这样，所以还是要手动push git config user.name “”git config user.email “”git add *git commit -m “”git remote add origin git@github.com:你的GitHub用户名/本地仓库 此时若提示，fatal: remote origin already exists,则 先删除远程Git仓库 git remote rm origin 再添加远程Git仓库 git remote add origin git@github.com:你的GitHub用户名/本地仓库 接着执行 git push origin master 当远程库和本地库不同步时，会提示，error：failed to push some refes to ….,则 先pull,将远程库文件同步下来 git pull origin master 再push，执行推送 git push origin master Finish!]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F01%2F02%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[之后会陆续更新python数据分析有关内容 numpy库 pandas库 深入pandas pandas数据读写 用matplotlib实现数据可视化]]></content>
      <tags>
        <tag>我的第一篇博客</tag>
      </tags>
  </entry>
</search>
