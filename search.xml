<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pandas]]></title>
    <url>%2F2018%2F02%2F20%2Fpandas%2F</url>
    <content type="text"><![CDATA[1. Series对象Series对象用来表示一维数组结构，跟数组类似，但多了一些额外的功能。 (1) 调用Series()构造函数，把要存放在Series对象中的数据以数组形式传入。 import pandas as pdimport numpy as npa = pd.Series([1,2,3,4]) (2) 输出结果左侧index是一列标签，右侧是标签对应的元素values(3) 选择内部元素，可以使用元素对应的标签，把标签放到数组中。 a[[‘0’,’1’]] (4) 用Numpy数组或其他Series对象定义新Series对象 b = np.array([1,2,3])a1 = pd.Series(b) (5) unique()函数可弄清Series对象包含多少个不同的元素，其结果返回一个包含Series去重后的元素; value_counts()函数返回各个不同的元素，计算每个元素在Series中出现的次数。 a.unique()a.value_counts() (6) isin()函数判断给定的元素是否包含在数据结构之中，isin()函数返回布尔值。 a.isin([1]) (7) NaN(Not a Number,非数值)，创建数据结构时，可为数组中元素缺失的项输入np.NaN；isnull()和 notnull()函数用来识别没有对应元素的索引时非常好用,作为筛选函数。(8) 可以用事先定义好的字典来创建Series对象。索引数组为字典的键。可以单独指定索引，若遇缺失值，pandas就会为其添加NaN。(9) Series对象之间的运算，只对标签相同的元素运算，其余的也被添加到新对象中，它们的值均为NaN。 2.DataFrame对象 DataFrame对象可以理解为一个由Series组成的字典。DataFrame对象有两个索引数组，第一个数组与行相关，与Series对象的索引数组相似，第二个数组和列相关，每一列的名称为字典的键。DataFrame对象用columns选项指定需要的列，也可指定列名称的顺序。在未指明索引的情况下，Series对象和DataFrame对象，都会自动添加一列从0开始的数值作为索引，用标签作为索引，则把标签放到数组中，赋给index选项。 (1) 定义DataFrame对象传递一个dict对象给DataFrame()构造函数，dict对象以每一列的名称作为键，每个键都有一个数组作为值。 import pandas as pddata = {‘color’:[‘blue’,’yellow’,’green’], ‘price’:[3,4,5]}frame = pd.DataFrame(data) 抛开dict对象，定义一个构造函数，参数顺序：数据矩阵、index选项和columns选项 。 frame1 = pd.DataFrame(np.arange(16).reshape((4,4)), index = [‘red’,’blue’,’yellow’,’green’], columns = [‘pen’,’pencil’,’ruler’,’box’]) (2) 选取元素调用columns属性可知DataFrame对象所有列的名称，调用index属性可知DataFrame对象所有行的名称，调用values属性可获取存储在数据结构中的元素。 frame = pd.DataFrame(data)print(frame.columns)print(frame.index)print(frame.values) 把 一列的名称作为索引可选择这一列的内容 frame[‘price’] 或 用列名称作为DataFrame实例的属性，也可选择这一列的内容 frame.price 还可通过指定 索引范围(切片)来选取 frame[0:2] 依次指定元素所在的列名称、行的索引值或标签，可获取存储在DataFrame中的一个元素。 frame[‘color’][‘2’] (3) 赋值可用 name属性为二级结构columns属性和index属性指定标签。 frame.index.name = ‘id’;frame.columns.name = ‘item’ 指定DataFrame实例新列的名称，为其赋值可添加列。 frame[‘new’] = 10 若更新一列的内容，需要把一个数组赋给这一列。给某一列的其中几个索引所对应的值赋新值，没有被赋新值的元素会填充为NaN。 frame[‘price’] = [4,5,6] (4) 元素所属关系isin()函数判断一组元素是否属于Series对象，同样适用DataFrame对象。 (5) 删除一列使用del命令，可以删除一整列的所有数据。 del frame[‘new’] (6) 筛选 frame[frame &lt; 12]返回的对象包含所有小于12的数字，不符合条件的替换为NaN。 (7) DataFrame转置调用T属性就能得到DataFrame对象的转置形式。 frame.T 3.index对象(1) index对象的方法idxmin()和idxmax()函数分别返回索引值最小和最大的元素。 frame.idxmin()frame.idxmax() 运用is_unique属性，可判断数据结构中是否存在重复的索引项，返回bool值。 frame.index.is_unique (2) 更换索引数据结构一旦声明，index对象就不能改变，但pandas的reindex()函数可更换Series对象的索引，根据新标签序列，重新调整原Series对象元素，生成一个新的Series对象。更换索引时，可以调整索引序列中各标签的顺序，删除或增加标签，增加新标签，pandas会增加NaN作为其元素。 frame.reindex([‘one’,’two’,’three’,’four’]) 当索引列缺失值时，常见的需求为插值，以得到一个完整的序列，方法是用reindex()函数，method选项值可为ffill或bfill。当为ffill时，对于新插入的索引项，其元素为前面索引编号比它小的那一项的元素，当为bfill时，是新插入索引后面的元素。 frame.reindex([‘one’,’two’,’three’,’four’],method = ‘ffill’) (3) 删除删除操作drop()函数，将想删除的标签作为drop()函数的参数，删除多项时，传入一个由多标签组成的数组。在Series对象中操作。 ser = pd.Series(np.arange(3),index = [‘red’,’blue’,’yellow’])ser.drop(‘red’) 要删除DataFrame对象中的元素，需要指定元素两个轴的轴标签，传入行的索引可以删除行。要删除列，需要指定列的索引，还需用axis选项指定从哪个轴删除元素，按列的方向删除，axis的值为1。 frame.drop([‘blue’,’yellow’])frame.drop([‘pen’,’pencil’],axis = 1) (4) 算术和数据对齐DataFrame对象之间的运算，行和列都要执行对齐操作。例:有两个DataFrame对象，frame1和frame2 frame1 + frame2 也可写为frame1.add(frame2)—–算术运算方法 (5) 按行或按列执行操作的函数用apply()函数可以在DataFrame对象上使用自定义的函数，可返回Series对象或DataFrame对象。 (6) 统计函数数组的大多数统计函数对DataFrame对象依旧有效，deccribe()函数能够计算多个统计量。 frame.deccribe() (7) 排序对于Series对象，pandas的sort_index()函数可按照索引的升序排列的顺序对标签进行排序，若按照降序排列，只需将sort_index()函数的参数设为sort_index(ascending=False)。 ser.sort_index()ser.sort_index(ascending=False) 对于DataFrame对象，可分别对两条轴中的任意一条进行排序。对索引进行排序，sort_index()函数可以解决，若按列进行排序，只需将sort_index()函数的参数设定为sort_index(axis = 1)。 frame.sort_index()frame.sort_index(axis = 1) 以上为对索引进行排序，下面为对数据元素进行排序。对Series对象排序，使用sort_values()函数，对DataFrame对象排序，使用sort_values()函数，参数需要用by选项指定根据哪一列进行排序。 ser.sort_values()frame.sort_values(by = ‘pen’) sort_values()对多列进行排序，把这些列的名称放到数组中，赋给参数by。 frame.sort_values(by = [‘pen’,’pencil’]) (8) 相关性和协方差相关性和协方差是非常重要的两个统计量，函数分别为corr()和cov()。涉及两个Series对象，单个DataFrame对象。 4.NaN数据(1) 为元素赋NaN值运用numpy的np.NaN(或np.nan)即可。 (2) 过滤NaN对于Series对象，dropna()函数可以删除所有的NaN值，另一种方法是用notnull()函数作为选取元素的条件，直接实现过滤。 ser.dropna()ser[ser.notnull()] DataFrame对象若用dropna()方法，只要行或列有一个NaN元素，该行或该列的元素都会被删除。可使用how选项，指定其值为all，只删除所有元素均为NaN的行或列。 frame.dropna(how = ‘all’) (3) 为NaN元素填充其他值将所有NaN值替换为同一个元素，fillna()函数。将不同列的NaN替换为不同的元素，依次指定列名称及要替换成的元素即可。]]></content>
      <categories>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy]]></title>
    <url>%2F2018%2F02%2F01%2Fnumpy%2F</url>
    <content type="text"><![CDATA[1.numpy中的基本数据类型 名称 描述 bool 用一个字节存储的布尔类型（True或False） inti 由所在平台决定其大小的整数（一般为int32或int64） int8 一个字节大小，-128 至 127 int16 整数，-32768 至 32767 int32 整数，-231 至 232-1 int64 整数，-263 至 263 - 1 uint8 无符号整数，0 至 255 uint16 无符号整数，0 至 65535 uint32 无符号整数，0 至 232 - 1 uint64 无符号整数，0 至 264 - 1 float16 半精度浮点数：16位，正负号1位，指数5位，精度10位 float32 单精度浮点数：32位，正负号1位，指数8位，精度23位 float64或float 双精度浮点数：64位，正负号1位，指数11位，精度52位 complex64 复数，分别用两个32位浮点数表示实部和虚部 complex128或complex 复数，分别用两个64位浮点数表示实部和虚部 2.用于操作单个数组的常用函数 函数 说明 sort(x) 对x进行从小到大排序 unique(x) 计算x中的唯一元素，并返回有序结果 abs、fabs 计算整数、浮点数或复数的绝对值。对于复数数值，可以使用更快的fabs square 计算各元素的平方 sqrt 计算各元素的平方根 cos、sin、tan 三角函数 arccos、arcsin、arctan 反三角函数 3.用于操作两个或多个数组的方法 函数 说明 add 将数组中对应的元素相加 subtract 从第一个数组中减去第二个数组中的元素 multiply 数组元素相乘 power 两个数组A,B，计算A的B次方 mod 元素级的求模运算 4.数学统计方法 方法 说明 sum 求和 mean 算术平均数。零长度的数组为NaN std、var 分别为标准差和方差 min，max 最小值和最大值 cumsum 所有元素的累积和 cumprod 所有元素的累积积 argmin、argmax 分别计算最小值和最大值的索引 5.线性函数的常用方法 函数 描述 dot 矩阵乘法 trace 计算对角线元素的和 det 计算矩阵行列式 inv 计算方阵的逆 pinv 计算矩阵的逆 6.实例 >&gt;&gt; import numpy as np 调用numpy库>&gt;&gt; a = np.array([1,2,3]) 创建数组，且大小固定，不可变>&gt;&gt; aarray([1, 2, 3])>&gt;&gt; a.dtype 查看新建的ndarray属于哪种数据类型dtype(‘int32’)>&gt;&gt; a.ndim 数组的维统称为轴，得出轴数量（秩）1>&gt;&gt; a.size 数组的长度3>&gt;&gt; a.shape 数组的型(3,)>&gt;&gt; b = np.array([[1,2,3],[2,3,4]]) 创建二维数组>&gt;&gt; barray([[1, 2, 3], [2, 3, 4]])>&gt;&gt; c = np.array(((1,2,4),(4,5,6)))>&gt;&gt; carray([[1, 2, 4], [4, 5, 6]])>&gt;&gt; d = np.array([(1,2,3),[4,5,6],(7,8,9)])>&gt;&gt; darray([[1, 2, 3], [4, 5, 6], [7, 8, 9]])>&gt;&gt; f = np.array([(1,2,3),[4,5,6],(7,8,9)],dtype = complex) complex为复数类型>&gt;&gt; farray([[ 1.+0.j, 2.+0.j, 3.+0.j], [ 4.+0.j, 5.+0.j, 6.+0.j], [ 7.+0.j, 8.+0.j, 9.+0.j]])>&gt;&gt; np.zeros((3,3)) 生成全0的数组array([[ 0., 0., 0.], [ 0., 0., 0.], [ 0., 0., 0.]])>&gt;&gt; np.ones((3,3)) 生成全1的数组array([[ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.]]) empty()函数，随机生成数组，相当于未进行初始化的数组。不同平台调用会生成不同的结果。(2,3,2)：2个3行2列的数组。>&gt;&gt;np.empty((2,3,2))>&gt;&gt; np.arange(0,10) 遍历输出array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])>&gt;&gt; np.arange(0,10,3) 类似于列表，不同的是列表的大小可以改变array([0, 3, 6, 9])>&gt;&gt; np.arange(0,12).reshape(3,4) 生成3行4列的数组array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])>&gt;&gt; np.random.random((3,3)) 产生随机数array([[ 0.24683936, 0.49185243, 0.30907375], [ 0.73396599, 0.56047708, 0.07133656], [ 0.46251468, 0.00697587, 0.9234071 ]])>&gt;&gt; A = np.ones((3,3))>&gt;&gt; Aarray([[ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.]])>&gt;&gt; B = np.arange(0,9).reshape(3,3)>&gt;&gt; Barray([[0, 1, 2], [3, 4, 5], [6, 7, 8]])>&gt;&gt; np.dot(A,B) dot表示两个数组的矩阵积array([[ 9., 12., 15.], [ 9., 12., 15.], [ 9., 12., 15.]])>&gt;&gt; A.dot(B) 矩阵积的第二种表示形式array([[ 9., 12., 15.], [ 9., 12., 15.], [ 9., 12., 15.]]) 数学运算>&gt;&gt; g = np.arange(4)>&gt;&gt; garray([0, 1, 2, 3])>&gt;&gt; g += 1>&gt;&gt; garray([1, 2, 3, 4])>&gt;&gt; g -= 2>&gt;&gt; garray([-1, 0, 1, 2])>&gt;&gt; h = np.arange(1,5)>&gt;&gt; harray([1, 2, 3, 4])>&gt;&gt; np.sqrt(h) 开平方array([ 1. , 1.41421356, 1.73205081, 2. ])>&gt;&gt; np.sin(h)array([ 0.84147098, 0.90929743, 0.14112001, -0.7568025 ])>&gt;&gt; np.log(h)array([ 0. , 0.69314718, 1.09861229, 1.38629436])>&gt;&gt; k = np.array([3,4,5,6,7])>&gt;&gt; k.sum() 求和25>&gt;&gt; k.min() 最小值3>&gt;&gt; k.max() 最大值7>&gt;&gt; k.mean() 平均值5.0>&gt;&gt; k.std() 标准差1.4142135623730951>&gt;&gt; l = np.arange(10,19).reshape((3,3))>&gt;&gt; larray([[10, 11, 12], [13, 14, 15], [16, 17, 18]])>&gt;&gt; np.apply_along_axis(np.mean,axis = 0,arr = l) 遍历每个元素，求每一列的平均值array([ 13., 14., 15.])>&gt;&gt; np.apply_along_axis(np.mean,axis = 1,arr = l) 求每一行的平均值array([ 11., 14., 17.])>&gt;&gt; m = np.random.random((4,4))>&gt;&gt; marray([[ 0.08614139, 0.7518394 , 0.45196265, 0.68611206], [ 0.62034675, 0.52529466, 0.72000524, 0.90689477], [ 0.19201244, 0.4555663 , 0.16900424, 0.76753676], [ 0.17563723, 0.6348416 , 0.38004357, 0.92354182]])>&gt;&gt; b = np.random.random(12)>&gt;&gt; barray([ 0.56181788, 0.16499619, 0.6756252 , …, 0.33440496, 0.75068239, 0.08420334])>&gt;&gt; b.shape = (3,4) 把元组赋给数组shape的属性>&gt;&gt; barray([[ 0.56181788, 0.16499619, 0.6756252 , 0.37539411], [ 0.53771165, 0.96114175, 0.58014551, 0.05676748], [ 0.31388188, 0.33440496, 0.75068239, 0.08420334]])>&gt;&gt; b.ravel() 把二维数组变为一维数组array([ 0.56181788, 0.16499619, 0.6756252 , …, 0.33440496, 0.75068239, 0.08420334])>&gt;&gt; b.transpose() 行列转换array([[ 0.56181788, 0.53771165, 0.31388188], [ 0.16499619, 0.96114175, 0.33440496], [ 0.6756252 , 0.58014551, 0.75068239], [ 0.37539411, 0.05676748, 0.08420334]])>&gt;&gt; A = np.zeros((3,3))>&gt;&gt; B = np.ones((3,3))>&gt;&gt; np.vstack((A,B)) 执行垂直入栈操作array([[ 0., 0., 0.], [ 0., 0., 0.], [ 0., 0., 0.], [ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.]])>&gt;&gt; np.hstack((A,B)) 执行水平入栈操作array([[ 0., 0., 0., 1., 1., 1.], [ 0., 0., 0., 1., 1., 1.], [ 0., 0., 0., 1., 1., 1.]]) 用于多个数组之间的栈操作>&gt;&gt; d = np.array([1,2,3])>&gt;&gt; e = np.array([4,5,6])>&gt;&gt; f = np.array([7,8,9])>&gt;&gt; np.column_stack((d,e,f)) 把一维数组作为列压入栈array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])>&gt;&gt; np.row_stack((d,e,f)) 把一维数组作为行压入栈array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])>&gt;&gt; C = np.arange(16).reshape((4,4))>&gt;&gt; Carray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])>&gt;&gt; [D,E] = np.hsplit (C,2) 将数组水平切分>&gt;&gt; Darray([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]])>&gt;&gt; Earray([[ 2, 3], [ 6, 7], [10, 11], [14, 15]])>&gt;&gt; [D,E] = np.vsplit (C,2) 将数组垂直切分>&gt;&gt; Darray([[0, 1, 2, 3], [4, 5, 6, 7]])>&gt;&gt; Earray([[ 8, 9, 10, 11], [12, 13, 14, 15]]) Numpy中，所有赋值运算不会为数组和数组中的任何元素创建副本。把数组a赋给数组b，b只是a的另外一种调用方式。>&gt;&gt; import numpy as np>&gt;&gt; a = np.array([1,2,3,4])>&gt;&gt; b = a>&gt;&gt; barray([1, 2, 3, 4])>&gt;&gt; a[2] = 5>&gt;&gt; barray([1, 2, 5, 4])>&gt;&gt; aarray([1, 2, 5, 4]) 利用copy()函数可以生成一份完整的副本，得到一个不同的数组。>&gt;&gt; d = a.copy()>&gt;&gt; darray([0, 2, 5, 4])>&gt;&gt; a[2] = 3>&gt;&gt; aarray([0, 2, 3, 4])>&gt;&gt; darray([0, 2, 5, 4]) 数组切片操作返回的对象只是原数组的视图。>&gt;&gt; l = np.arange(10,19).reshape((3,3))>&gt;&gt; larray([[10, 11, 12], [13, 14, 15], [16, 17, 18]])>&gt;&gt; l[2,2] 表示第3行3列的元素，从0开始18>&gt;&gt; l[1,2]15>&gt;&gt; l[0,:] 第0行的元素array([10, 11, 12])>&gt;&gt; l[:,0] 第0列的元素array([10, 13, 16])>&gt;&gt; l[0:2,0:2] 截取前两行前两列的元素array([[10, 11], [13, 14]])>&gt;&gt; l[[0,2],0:2] 截取前两列中第0行、第2行的元素array([[10, 11], [16, 17]])>&gt;&gt; c = a[0:2]>&gt;&gt; carray([1, 2])>&gt;&gt; a[0] = 0>&gt;&gt; carray([0, 2])>&gt;&gt; d = np.array([[1,2,3],[4,5,6],[7,8,9]])>&gt;&gt; darray([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 切片：一个逗号表示一个维度。:2表示数组的前两行(0,1行)，1：数组的1列到最后一列。>&gt;&gt; d[:2,1:]array([[2, 3], [5, 6]])>&gt;&gt; d[:2]array([[1, 2, 3], [4, 5, 6]]) 可以利用切片为数组赋值。>&gt;&gt; d[1:,2:] = 0>&gt;&gt; darray([[1, 2, 3], [4, 5, 0], [7, 8, 0]])]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2018%2F01%2F26%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo搭建博客基本命令添加相关页面打开终端，进入博客根站点目录下，例：添加标签页，输入以下内容： hexo new page tags 生成静态文件 hexo g 本地预览 hexo s 部署到GitHub打开终端，进入public hexo d 但往往hexo d不起作用，我的是这样，所以还是要手动push git config user.name “”git config user.email “”git add *git commit -m “”git remote add origin git@github.com:你的GitHub用户名/本地仓库 此时若提示，fatal: remote origin already exists,则 先删除远程Git仓库 git remote rm origin 再添加远程Git仓库 git remote add origin git@github.com:你的GitHub用户名/本地仓库 接着执行 git push origin master 当远程库和本地库不同步时，会提示，error：failed to push some refes to ….,则 先pull,将远程库文件同步下来 git pull origin master 再push，执行推送 git push origin master Finish!]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F01%2F02%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[之后会陆续更新python数据分析有关内容 numpy库 pandas库 深入pandas pandas数据读写 用matplotlib实现数据可视化]]></content>
      <tags>
        <tag>我的第一篇博客</tag>
      </tags>
  </entry>
</search>
